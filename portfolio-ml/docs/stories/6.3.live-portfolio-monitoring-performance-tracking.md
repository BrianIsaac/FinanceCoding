# <!-- Powered by BMAD™ Core -->

# Story 6.3: Live Portfolio Monitoring and Performance Tracking

## Status
Draft

## Story
**As a** portfolio manager,
**I want** real-time portfolio monitoring with detailed performance tracking and holdings analysis,
**so that** I can make informed decisions about my investments and track AI-driven portfolio changes.

## Acceptance Criteria

1. **Real-Time Portfolio Dashboard**: Live display of portfolio value, daily P&L, monthly performance, and AI strategy status
2. **Holdings Analysis**: Detailed breakdown of current positions with weights, performance attribution, and sector allocation
3. **Performance Attribution**: Clear identification of top performers and underperformers with AI-driven insights
4. **AI Activity Tracking**: Timeline of recent AI-driven portfolio changes with rationale and impact analysis
5. **Risk Monitoring**: Real-time risk metrics including portfolio volatility, correlation exposure, and constraint compliance
6. **Historical Performance**: Interactive charts showing portfolio performance over time with benchmark comparisons

## Tasks / Subtasks

- [ ] Task 1: Real-Time Portfolio Dashboard (AC: 1)
  - [ ] Subtask 1.1: Create live portfolio value calculation and display system
  - [ ] Subtask 1.2: Implement daily P&L tracking with percentage and absolute changes
  - [ ] Subtask 1.3: Build monthly and YTD performance metrics with benchmark comparison
  - [ ] Subtask 1.4: Add AI strategy status indicators with model confidence levels
  
- [ ] Task 2: Holdings Analysis Framework (AC: 2)
  - [ ] Subtask 2.1: Create detailed holdings table with sortable columns and filtering
  - [ ] Subtask 2.2: Implement sector allocation visualization with interactive charts
  - [ ] Subtask 2.3: Add position sizing analysis with constraint compliance indicators
  - [ ] Subtask 2.4: Build holdings performance attribution analysis
  
- [ ] Task 3: Performance Attribution System (AC: 3)
  - [ ] Subtask 3.1: Identify and display top/bottom performers with contribution analysis
  - [ ] Subtask 3.2: Calculate sector and factor attribution for portfolio returns
  - [ ] Subtask 3.3: Create performance attribution visualization with drill-down capability
  - [ ] Subtask 3.4: Add comparison with strategy benchmark and peer performance
  
- [ ] Task 4: AI Activity Timeline (AC: 4)
  - [ ] Subtask 4.1: Create AI decision logging system for portfolio changes
  - [ ] Subtask 4.2: Build timeline visualization of recent AI actions and rationale
  - [ ] Subtask 4.3: Add impact analysis showing before/after performance metrics
  - [ ] Subtask 4.4: Implement AI confidence scoring and decision quality tracking
  
- [ ] Task 5: Risk Monitoring Dashboard (AC: 5)
  - [ ] Subtask 5.1: Calculate and display real-time portfolio risk metrics
  - [ ] Subtask 5.2: Monitor constraint compliance with violation alerts
  - [ ] Subtask 5.3: Track correlation exposure and concentration risk
  - [ ] Subtask 5.4: Add risk-adjusted performance metrics with historical context
  
- [ ] Task 6: Historical Performance Charts (AC: 6)
  - [ ] Subtask 6.1: Create interactive time-series performance charts
  - [ ] Subtask 6.2: Add benchmark overlay with relative performance analysis
  - [ ] Subtask 6.3: Implement drawdown analysis with recovery period identification
  - [ ] Subtask 6.4: Build rolling performance metrics with customizable time periods

## Dev Notes

### Integration with Existing Performance Framework

**Performance Data Sources:**
- **Portfolio Positions**: Load from `results/latest_portfolio_weights.csv` and historical position files
- **Returns Data**: Use existing price data from `data/final_new_pipeline/` for P&L calculation
- **Performance Analytics**: Leverage `src/evaluation/reporting/tables.py` for metrics calculation
- **AI Model Results**: Track decisions from model prediction outputs and rebalancing logs

**Real-Time Calculation Architecture:**
```python
class PortfolioMonitor:
    def __init__(self, portfolio_config):
        self.config = portfolio_config
        self.performance_calculator = PerformanceAnalytics()
        self.attribution_engine = PerformanceAttribution()
        
    def calculate_current_value(self):
        """Calculate current portfolio value using latest prices"""
        positions = self.load_current_positions()
        latest_prices = self.get_latest_prices()
        return positions.dot(latest_prices)
    
    def track_daily_pnl(self):
        """Calculate daily P&L with attribution breakdown"""
        # Implementation using existing performance framework
        pass
```

### AI Activity Tracking System

**Decision Logging Framework:**
```python
# Enhanced model classes to log decisions
class AIDecisionLogger:
    def __init__(self, model_name, portfolio_id):
        self.model = model_name
        self.portfolio = portfolio_id
        
    def log_rebalancing_decision(self, old_weights, new_weights, rationale):
        """Log AI-driven portfolio changes with reasoning"""
        decision_log = {
            "timestamp": datetime.now(),
            "model": self.model,
            "action": "rebalancing",
            "changes": self.calculate_position_changes(old_weights, new_weights),
            "rationale": rationale,
            "confidence": self.model.last_prediction_confidence,
            "expected_impact": self.estimate_performance_impact(old_weights, new_weights)
        }
        
        self.save_decision_log(decision_log)
    
    def calculate_position_changes(self, old_weights, new_weights):
        """Identify significant position changes for user display"""
        changes = []
        for ticker in set(old_weights.index) | set(new_weights.index):
            old_weight = old_weights.get(ticker, 0)
            new_weight = new_weights.get(ticker, 0)
            change = new_weight - old_weight
            
            if abs(change) > 0.005:  # 0.5% threshold
                changes.append({
                    "ticker": ticker,
                    "old_weight": old_weight,
                    "new_weight": new_weight,
                    "change": change,
                    "action": "increased" if change > 0 else "decreased"
                })
        return changes
```

### Holdings Analysis Integration

**Position Analysis Framework:**
```python
class HoldingsAnalyzer:
    def __init__(self, portfolio_positions, market_data):
        self.positions = portfolio_positions
        self.market_data = market_data
        
    def analyze_sector_allocation(self):
        """Calculate current sector exposure with visualizations"""
        # Use existing sector mapping and visualization tools
        from src.evaluation.reporting.charts import TimeSeriesCharts
        charts = TimeSeriesCharts()
        return charts.create_sector_allocation_chart(self.positions)
    
    def calculate_position_performance(self):
        """Analyze individual position contribution to portfolio returns"""
        # Integration with existing performance attribution
        return self.attribution_engine.calculate_position_attribution(
            self.positions, self.market_data
        )
```

### Risk Monitoring Integration

**Risk Metrics Integration:**
```python
# Leverage existing risk analytics
from src.evaluation.reporting.risk_return import RiskReturnAnalysis
from src.models.base.constraints import PortfolioConstraints

class RealTimeRiskMonitor:
    def __init__(self, portfolio_constraints):
        self.constraints = portfolio_constraints
        self.risk_analyzer = RiskReturnAnalysis()
        
    def check_constraint_compliance(self, current_positions):
        """Monitor constraint violations with user-friendly alerts"""
        violations = []
        
        # Check position limits
        max_position = current_positions.max()
        if max_position > self.constraints.max_position_weight:
            violations.append({
                "type": "position_limit",
                "severity": "high",
                "message": f"Position exceeds {self.constraints.max_position_weight:.1%} limit",
                "current_value": max_position,
                "recommendation": "Consider rebalancing oversized positions"
            })
        
        return violations
    
    def calculate_portfolio_risk(self, positions, returns_data):
        """Calculate real-time portfolio risk metrics"""
        # Use existing risk calculation framework
        return self.risk_analyzer.calculate_portfolio_metrics(positions, returns_data)
```

### User Interface Components

**Dashboard Layout Structure:**
```
components/portfolio_monitoring/
├── portfolio_summary.py       # Top-level metrics and status
├── holdings_table.py          # Detailed position analysis
├── performance_charts.py      # Historical performance visualization  
├── ai_activity_feed.py        # Timeline of AI decisions
├── risk_monitor.py           # Risk metrics and alerts
└── attribution_analysis.py   # Performance attribution breakdown
```

**Real-Time Data Updates:**
```python
# Streamlit auto-refresh for live monitoring
def setup_auto_refresh():
    """Configure automatic dashboard refresh for live monitoring"""
    if st.checkbox("Enable Live Updates", value=True):
        # Refresh every 30 seconds during market hours
        refresh_interval = 30 if is_market_hours() else 300
        st_autorefresh(interval=refresh_interval * 1000)
```

### Performance Attribution Framework

**Attribution Analysis Integration:**
```python
class PerformanceAttributionUI:
    def __init__(self, portfolio_returns, benchmark_returns):
        self.portfolio_returns = portfolio_returns
        self.benchmark_returns = benchmark_returns
        
    def create_attribution_breakdown(self):
        """Create user-friendly performance attribution analysis"""
        attribution = self.calculate_brinson_attribution()
        
        # Create visual breakdown for users
        attribution_chart = self.create_attribution_waterfall_chart()
        attribution_table = self.create_attribution_summary_table()
        
        return {
            "chart": attribution_chart,
            "table": attribution_table,
            "summary": self.create_attribution_summary()
        }
```

## Testing

### Testing Strategy

**Real-Time Functionality Testing:**
- Portfolio value calculation accuracy with live price feeds
- P&L calculation verification against manual calculations
- Performance attribution accuracy with known test cases
- Auto-refresh functionality under various conditions

**Data Integration Testing:**
- Consistency between UI displays and backend calculations
- Historical data loading and processing performance
- AI decision log integration and display accuracy
- Risk monitoring alert generation and accuracy

**User Experience Testing:**
- Dashboard responsiveness with large portfolios (50+ positions)
- Interactive chart functionality and drill-down capabilities
- Mobile experience for portfolio monitoring
- Error handling for data unavailability scenarios

**Performance Testing:**
- Dashboard loading time with full portfolio data
- Real-time calculation performance for large portfolios
- Memory usage optimization for continuous monitoring
- Concurrent user load testing

### Test Coverage Requirements

```
tests/frontend/portfolio_monitoring/
├── test_portfolio_calculations.py    # P&L and value calculations
├── test_holdings_analysis.py         # Position analysis accuracy
├── test_performance_attribution.py   # Attribution calculation testing
├── test_ai_activity_tracking.py     # Decision logging and display
├── test_risk_monitoring.py          # Risk metrics and compliance
└── test_integration.py              # End-to-end monitoring workflow
```

### Performance Benchmarks

**Response Time Requirements:**
- Dashboard initial load: <3 seconds
- Portfolio value calculation: <1 second
- Holdings analysis refresh: <2 seconds
- Performance attribution: <5 seconds
- Historical chart rendering: <3 seconds

**Accuracy Requirements:**
- Portfolio value calculation: 100% accuracy vs manual calculation
- P&L attribution: <0.1% variance from benchmark calculation
- Risk metrics: Consistent with existing backend calculations
- AI decision tracking: Complete capture of model decisions

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-14 | 1.0 | Initial story creation for portfolio monitoring interface | James (Full Stack Developer) |

## Dev Agent Record

### Agent Model Used
[To be filled during implementation]

### Completion Notes
[To be filled during implementation]

### File List
[To be filled during implementation]

### Change Log
[To be filled during implementation]

### Debug Log References
[To be filled during implementation]